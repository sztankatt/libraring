#Libraring project usr/views.py file
#Created by: Tamas Sztanka-Toth

from django.shortcuts import render_to_response, get_object_or_404, render
from django.http import HttpResponse, HttpResponseRedirect
from django.contrib.formtools.wizard.views import SessionWizardView
from django.core.mail import send_mail
from django.core.urlresolvers import reverse
from django.template import RequestContext
from django.contrib.auth.models import User
from django.contrib.auth import login, logout, authenticate
from django.contrib.auth.decorators import login_required
from django.utils.decorators import method_decorator
from django.views.generic.detail import DetailView
from django.contrib import messages

from usr.forms import RegisterPersonForm, ClassForm, NClassForm, InstitutionForm,\
    UserCreationForm, LoginForm
from usr.models import Class, Institution, Person, PageMessages
from usr.project import PROJECT_NAME, REGISTRATION_EMAIL, PROJECT_URL, user_is_not_blocked

import string
import random

def test(request):
	return render_to_response(request, 'ajaxSubmit.html');

#Data and functions for RegisterWizardView
FORMS = [	("user",UserCreationForm),
		("person",RegisterPersonForm),
		("class",ClassForm),
		("institution", InstitutionForm)
	]
		
TEMPLATES = {
		"user":"before_login/registration/user.html",
		"person":"before_login/registration/person.html",
		"class":"before_login/registration/class.html",
		"institution":"before_login/registration/institution.html"
	}

#returns true iff the checkbox is set to student
def is_student(wizard):
	cleaned_data = wizard.get_cleaned_data_for_step('person') or {'person_type': 'none'}
	return cleaned_data['person_type'] == 'S'

#return true iff the checkbox is not set to student
def is_not_student(wizard):
	return not is_student(wizard)

#helper functions for generating confirmation code for the user
def generate_random(size=50, chars=string.ascii_uppercase + string.ascii_lowercase + string.digits):
	return ''.join(random.choice(chars) for _ in range(size))

#confirmation code generator. Checks whether the given code already exists, if yes, generates a
#new one
def confirmation_code_generator():
	code = generate_random()
	while Person.objects.filter(confirmation_code=code).exists():
		code = generate_random()
		
	return code

#register wizard, using the Django's wizardView implementation
class RegisterWizard(SessionWizardView):
	condition_dict = {'class':is_student, 'institution':is_not_student}

	def get_template_names(self):
		return [TEMPLATES[self.steps.current]]
	
	#after the last form has been submitted, ie everything is correct
	def done(self,form_list, **kwargs):
		
		#fetching and saving the user from the data of the first form
		user = form_list[0].save(commit=False)
		
		
		#fetching the details of user from the second form
		#user.email = form_list[2].cleaned_data['email']
		user.first_name = form_list[1].cleaned_data['first_name']
		user.last_name = form_list[1].cleaned_data['last_name']
		user.is_active = False
		
		
		#fetching the user's person object
		person = form_list[1].save(commit=False)
		
		#managing the user's person object
		if person.person_type == 'S':
			education_data = form_list[2].cleaned_data
			current_education, created = Class.objects.get_or_create(
				institution=education_data['institution'], 
				course=education_data['course'], 
				start_year=education_data['start_year'], 
				end_year=education_data['end_year'])
			
			institution = None
			
			email = education_data['email'] + '@' + education_data['institution'].email_ending
		else: 
			institution = form_list[2].cleaned_data['institution']
			email = form_list[2].cleaned_data['email'] + '@' + institution.email_ending

			current_education = None
		
		#saving user.email, according to which institution was selected
		user.email = email
		user.save()
		
		person.user = user
		if current_education is not None:
		    person.education.add(current_education)
		person.institution = institution
		person.date_born = form_list[1].cleaned_data['date_born']
		person.confirmation_code = confirmation_code_generator()
		person.block_code = 3
		person.save()
		
		#send_confirmation_email(user)
		
		return render(self.request, 'before_login/registration/confirmation.html', {
			'user': user,
			'register_followup': True})

#Data and functions for confirm function, handling the user confirmation process
CONFIRMATION_EMAIL_DATA = {
		'subject'	: PROJECT_NAME + ' registration confirmation e-mail',
		'message'	: 'Plese click on the link below and follow the instructions to finish' \
			+'the registration', 
		'from_email'	: REGISTRATION_EMAIL,		
	}

def send_confirmation_email(user):
	content = CONFIRMATION_EMAIL_DATA['message']+'\n\n '+ PROJECT_URL + '/confirmation/' \
		+ user.person.confirmation_code +'/'
	send_mail(CONFIRMATION_EMAIL_DATA['subject'], content, CONFIRMATION_EMAIL_DATA['from_email'], \
		[user.email], fail_silently=False)
	


#managing user login. If there is a next parameter, sending the user to the next page.
#otherwise sending him to '/'
#/usr/login/
def login_view(request):
	data = {}
	username = password = ''
	user = None
	error = ''
	
	if request.user.is_authenticated():
		return HttpResponseRedirect(reverse('index'))
	
	if request.POST:
		form = LoginForm(request.POST)
		if form.is_valid():
			user = authenticate(username = request.POST['username'], \
					    password = request.POST['password'])
			error = 'Your username/password is incorrect. Are you registered?'

	else:
		form = LoginForm()
	
	next = ""
	
	if request.GET:
		next = request.GET['next']
	
	#if the user exists
	if user is not None:
	    login(request, user)
	    if next == "":
		return HttpResponseRedirect(reverse('index'))
	    else:
		return HttpResponseRedirect(next)
	    
	return render(request, 'before_login/auth/login.html', \
			{
				'form': form,
				'error': error
			})

#loggin out the user.
#/usr/logout
def logout_view(request):
	logout(request)
	return HttpResponseRedirect(reverse('index'))

#view which handles the loading of main page for logged in users. Only called within 'index' view
@user_is_not_blocked
def home(request):
	return render(request, 'after_login/usr/home.html')

#view which handles the access to the '/'
def index(request):
	#checks if the user is logged-in
	if request.user.is_authenticated():
		return home(request)
	
	return render(request, 'before_login/framework/index.html', {'form': LoginForm()})

@login_required
def blocked_profile(request):
    block_code = request.user.person.block_code
    if block_code == 0:
	return HttpResponseRedirect(reverse('index'))
    elif block_code == 1:
	logout(request)
	return HttpResponse('blocked profile')
	#todo: return render... new template
    else:
	return HttpResponseRedirect(reverse('confirmation_check'))

#confirmation page handling function
def confirm(request, confirmation_code=None):
	#TODO: confirmation template two variables.
	#the template is only activated when it has block 2 or 3 or if it had been confirmed now
	if request.user.is_authenticated():
	    block_code = request.user.person.block_code
	    user = request.user 
	    data = {}
	    
	    if block_code == 0:
		return HttpResponseRedirect(reverse('index'))
	    elif block_code == 2:
		data['email_confirm'] = True
		messages.add_message(request, messages.INFO, \
		    PageMessages.objects.get(name='new_email').message, extra_tags='alert alert-info')
	    elif block_code == 3:
		data['email_confirm'] = False
		if confirmation_code is None:
		    messages.add_message(request, messages.INFO, \
			PageMessages.objects.get(name='registry_confirmation').message)
		elif confirmation_code == user.person.confirmation_code:
		    user.person.block_code = 0
		    user.person.save()
		    user.is_active = True
		    user.save()
		    
		    return HttpResponseRedirect(reverse('index'))
		else:
		    messages.add_message(request, messages.ERROR, 'wrong confirmation code', extra_tags='test_error')
	else:
	    if confirmation_code is not None:
		user = get_object_or_404(Person, confirmation_code=confirmation_code)
		user.person.block_code = 0
		user.person.save()
		user.is_active = True
		user.save()
		return HttpResponseRedirect(reverse('index'))
	    else:
		return HttpResponseRedirect(reverse('usr:login'))
	
	return render(request, 'before_login/registration/confirmation.html')	

#view which loads the profile
@login_required
@user_is_not_blocked
def load_profile(request, id=None):
	
	#checking whether the id in the request was specified
	if id == None:
		id = request.user.id
	
	#becomes true if the user is viewing his own profile
	account_settings = False
	
	#fetching the user object		
	user = get_object_or_404(User, pk=id )
	
	#checking if the usser is viewging his/her own profile
	if id == user.id:
		account_settings = True
	
	#will be true if the user is a student
	student = False
	
	#checking if the user is a student
	if user.person.person_type == 'S':
		student = True
	
	#passing fields for the profile
	fields = [
		{
		    #username
		    'label'	: 'Username',
		    'data' 	: user.username,
		    'update'	: False,
		},
		{
		    #first-name
		    'label'	: 'First Name',
		    'data'	: user.first_name,
		    'update' 	: True,
		    'update_id' : 'first_name',
		    'form_id'	: 'first_name_form',
		},
		{
		    #last-name
		    'label'	: 'Last Name',
		    'data'	: user.last_name,
		    'update'	: True,
		    'update_id' : 'last_name',
		    'form_id'	: 'last_name_form',
		},
		{
		    #email
		    'label'	: 'e-mail',
		    'data'	: user.email,
		    'update'	: False,
		},
	]
	
	
	return render(request, 'after_login/usr/profile.html', {
	    'user' : user,
	    'fields' :fields,
	    'settings': account_settings,
	    'student': student,
	    'new_current_education_form':ClassForm(auto_id='new_current_education_%s'),
	    'new_previous_education_form':NClassForm(auto_id='new_previous_education_%s')
	})
